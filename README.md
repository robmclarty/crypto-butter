# Crypto Butter

Spread some crypto butter all over your project and scramble it into omelette-y
goodness ready to pour into the storage container of your choice. Also good for
squeezing into web inter-tubes for long-distance crypto flows. Act now, and get
all this, plus a limited time compression/decompression add-on for only six
monthly payments of $0.00.

## Huh?

- convert between Uint8Array and base64 or hex using [base64-js](https://github.com/beatgammit/base64-js)
- inflate & deflate your data using [pako](https://github.com/nodeca/pako)
- encrypt & decrypt with AES-256 CBC HMAC using a key of your choice
- sign & verify macs with SHA-512 signatures
- get random bytes
- PBKDF2 your PW using your own salt to get a SHA-256 hash

## Why?

This just mashes some functions from Node's Crypto Lib with some string and
compression functions to make a little package of crypto goodies that can help
you get going with some random good times using a more basic interface.

## Install

`npm install crypto-butter`

## Usage

### `getRandomBytes(size)`

size = how many bytes of randomness you want back as an int

returns = size * randome bytes

### `pbkdf(password, salt)`

password = a string that's, you know, not easy to guess ;)

salt = another string that's different than your password

returns = a promise that resolves to a key

### `sign(data, key)`

data = stuff you want to make a signature from

key = a key generated from `pbkdf()`

returns = a promise that resolves to a sha-512 hmac digest of your data smushed
together with your key

### `verify(data, key, mac, length)`

data = the stuff

key = made with `pbkdf()`

mac = hmac made from data and signature

length = size of data in bytes

returns = a resolved promise

### `hash(data)`

data = stuff to make hash

returns = a promise that resolves to an sha-512 hmac digest

### `encrypt_AES_CBC_HMAC(data, key)`

data = Uint8Array of stuff you want to encrypt

key = a key generated from `pbkdf()`

returns = an object containing iv, data, and mac as Uint8Arrays formatted as:

```javascript
{
  iv,
  data,
  mac
}
```

### `decrypt_AES_CBC_HMAC(data, key, iv, mac)`

data = ciphertext to be decrypted as Uint8Array

key = key generated by `pbkdf()`

iv = created from encrypt function as Uint8Array

mac = created from encrypt function as Uint8Array

returns = decrypted data as Uint8Array

### `base64FromBytes(data)`

data = a Uint8Array of stuff

returns = the equivalent base64 representation of that stuff

### `base64ToBytes(data)`

data = a base64-encoded string

returns = the equivalent Uint8Array representation of that string

### `hexFromBytes(data)`

data = a Uint8Array of stuff

returns = a hex string representation of that stuff

### `hexToBytes(data)`

data = a hex-encoded string

returns = a Uint8Array representation of that string

### `compress(data)`

data = a string of data you want to compress

returns = a Uint8Array of compressed data

### `decompress(data)`

data = a Uint8Array of compressed data

returns = a plain string of data

### `encodeBase64(data)`

data = a UTF-8 encoded string

returns = an equivalent base64-encoded string

### `decodeBase64(data)`

data = a base64-encoded string

returns = an equivalent UTF-8 encoded string

### `verifyMac(data, key, mac, calculatedMac, length)`

data = data that is MACed

key = the key used to MACify the data

mac = the original mac to compare

calculatedMac = a newly calculated mac from the data to verify the data didn't
change compared to the original mac

length = length of mac in bytes

returns = `true`, or it throws an error in your face

### `pack(data, iv, mac)`

data = Uint8Array of data to pack

iv = iv created from encrypt function

mac = mac created from encrypt function

returns = a string of base64-encoded data separated by `.` formatted as
`iv.data.mac`

### `unpack(data)`

data = a string created using `pack()` formatted as `iv.data.mac`

returns = an object containing the decoded iv, data, and mac each as Uint8Arrays
formatted as:

```javascript
{
  iv,
  data,
  mac
}
```

## Licesnse

[MIT](./LICENSE)

## Acknowledgements

I'm using [base64-js](https://github.com/beatgammit/base64-js) for encoding
stuff and [pako](https://github.com/nodeca/pako) for compression stuff. The rest
of the crypto parts are from the
[NodeJS Crypto module](https://nodejs.org/dist/latest-v8.x/docs/api/crypto.html).
